---
layout: post
title: C++迭代器
tags: CPP
categories: 技术文章
---
### 1 迭代器
#### 1.1 声明
```cpp
vector<int>::iterator iter = nums.begin();
```
#### 1.2 用法
循环遍历：
```cpp
for (iter = nums.begin();iter != nums.end();iter++){
	...
}
```
-读取元素的解引用运算符（`*`）。只能读元素，也就是解引用只能出现在赋值运算符的右边。
-箭头运算符（`->`），解引用迭代器，并提取对象的成员。
#### 1.3 迭代器类型

| 迭代器类型   | 功能                           |
| ------- | ---------------------------- |
| 输入迭代器   | 只允许从容器中读取元素，且不能重复读取同一元素。     |
| 输出迭代器   | 只允许向容器中写入元素，且不能重复写入同一位置。     |
| 前向迭代器   | 允许从容器中读写元素，并且可以向前移动，但不能向后移动。 |
| 双向迭代器   | 允许从容器中读写元素，并且可以向前或向后移动。      |
| 随机访问迭代器 | 允许从容器中读写元素，并可以随机访问任何位置的元素。   |
常用容器的迭代器：
- **vector ——随机访问迭代器**
- **deque——随机访问迭代器**
- **list —— 双向迭代器**
- **set / multiset——双向迭代器**
- **map / multimap——双向迭代器**
- **stack——不支持迭代器**
- **queue——不支持迭代器**
#### 1.4 注意
1. 逆序遍历，要用reverse_iterator，且从`rend()`开始：
```cpp
vector<int>::reverse_iterator it2 = nums.rend();
```
2. 反向迭代器的++操作是反向递增(向着`rbegin()`的方向)。
3. 反向迭代器转正向迭代器，要用`base()`方法，且**转过之后会向`rend()`方向移动一位**(即反向迭代器的`--`，如图，反向迭代器`ri`通过`base()`转为`i`，指向后移了1位)：
![](/images/2024-03-31-C++迭代器.png)
如果要保持指向的地址不变，需要在`base()`之后++(向begin方向移一位)：
```cpp
2个正向迭代器判相等：
while (it1 != it2) {...}
1正1反迭代器判相等(注意+1)：
while (it1 != it2.base()+1) {...}
```
4. 使用迭代器时，不能在循环体内做导致容器总大小变化的操作，如增加或删除元素，或者改变元素大小（如对于`vector<string>`，不能在循环体内改变string元素的长度），如有需要可用for循环。
### 2 sort()
#### 2.1 声明
传入STL容器的2个迭代器(一般为begin和end)和比较规则comp，对容器进行排序：
```C
void sort (Iterator first, Iterator last, Compare comp);
```
如果不传入比较规则，默认升序。
> 严格来说，`sort()`函数要求参数容器的迭代器类型为RandomAccessIterator，即随机访问迭代器。这就意味着`sort()`函数目前只对数组 (array)、向量(vector)、双队列生效(deque)**。
#### 2.2 用法
```C
sort(vec.begin(), vec.end()); //对vec进行升序排序
```
